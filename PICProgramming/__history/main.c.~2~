#include <main.h>

/*******************DEFINES*************************************************/ 
/* The address of the T731 with floating ADDR 1001100 */
#define T731_ADDR   0b10011000
#define I2C_WRITE_BIT   0b00000000
#define I2C_READ_BIT    0b00000001
/* T731 registers addr */
#define T731_STATUS_REG 0x04
#define T731_CONFIG_REG 0x01
#define T731_TEMP_REG   0x00
/* T731 register bits */
#define CONFIG_REG_ONESHOT 3 
#define T731_RES0 5
#define T731_RES1 6

/*The I2C adress of the Dallas DS1430 RTC*/
#define DS1430_ADDR         0xD0          
#define DS1430_CTL_REG      0x07   
#define DS1430_SEC_REG      0x00
#define DS1430_MIN_REG      0x01
#define DS1430_HOUR_REG     0x02
#define DS1430_DAY_REG      0x03
#define DS1430_DATE_REG     0x04
#define DS1430_MONTH_REG    0x05
#define DS1430_YEAR_REG     0x06

/* Size of EEPROM */
#define EEPROM_SIZE_BYTE (4096 / 14 - 1) // 1 adress = 2 * 32bit floats + 6 time bytes = 13 bytes

typedef enum {STATE_INIT = 0, OUR_STATE_IDLE, STATE_LOG_ENABLED, STATE_LOG_READ, STATE_LOG_DELETE, STATE_SET_RTC} state_t;
union bitwise_float_uint32_conversion
{
    unsigned int32 i;
    float f;
};

struct time_s {
   int sec;
   int min;
   int hour;
   int date;
   int month;
   int year;
};

/*******************GLOBAL VARIABLES****************************************/ 
unsigned int16 i_eeprom_write_adr = 0; /* EEPROM write address pointer */ 
union bitwise_float_uint32_conversion float_convert; /* Union used for conversion */

struct time_s initialTime = {30, 30, 12, 31, 10, 17};


/*******************FUNCTION DECLARATIONS***********************************/

/*******************I2C FUNCTIONS*******************************************/
 
/*******************************************************************
* DESCRIPTION :     Search the address space of the I2C to find connected devices
*
* INPUTS : None
* OUTPUTS : None
*
* NOTES : None
*/
void search_i2c()
{
  for (int i = 0; i <112; i ++)
  {
    i2c_start ();
    if (!i2c_write (i << 1))
    {
      printf ( "Found the device: 0x%X /n", i << 1);
    }
    i2c_stop ();
   }
}
 
/*******************************************************************
* DESCRIPTION :     Function used to write a command to a slave using I2C bus.
*
* INPUTS : 
*           addr  - slave address
*           reg   - register addres
*           value - command
*
* OUTPUTS : returns FALSE if the write was successful, TRUE in case of an error.
*
* NOTES : None
*/
int write_i2c(int addr, int reg, int value)
{
  int error = FALSE;
  i2c_start();    
  error |= i2c_write(addr | I2C_WRITE_BIT);
  error |= i2c_write(reg);
  error |= i2c_write(value);
  i2c_stop();
 
  return error;  
}
 
/*******************************************************************
* DESCRIPTION :     Function used to read 1 byte from a slave using I2C bus.
*
* INPUTS : 
*           addr  - slave address
*           reg   - register addres
*           value - pointer to save the result of the read
*
* OUTPUTS : returns FALSE if the write was successful, TRUE in case of an error.
*           returns the read value using the passed pointer (value)
*
* NOTES : This function allows to read a single byte.
*/
int read_i2c_int(int addr, int reg, int * value)
{
  int error = FALSE;
   
  /* First frame - device address and pointer to the register */
  i2c_start();
  error |= i2c_write(addr | I2C_WRITE_BIT);
  error |= i2c_write(reg);

  /* Restart communication */
  i2c_start();
  error |= i2c_write(addr | I2C_READ_BIT);

  /* Read 1 byte */
  *value = i2c_read(0);
   
  i2c_stop();
 
  return error;
}

/*******************************************************************
* DESCRIPTION :     Function used to read 2 bytes from a slave using I2C bus.
*
* INPUTS : 
*           addr  - slave address
*           reg   - register address
*           value - pointer to save the result of the read
*
* OUTPUTS : returns FALSE if the write was successful, TRUE in case of an error.
*           returns the read value using the passed pointer (value)
*
* NOTES : This function allows to read 2 bytes.
*/
int read_i2c_long(int addr, int reg, int16 * value)
{
  int firstByte;
  int secondByte;
  int error = FALSE;
   
  /* First frame - device address and pointer to the register */
  i2c_start();
  error |= i2c_write(addr | I2C_WRITE_BIT);
  error |= i2c_write(reg);
 
  /* Restart communication */
  i2c_start();
  error |= i2c_write(addr | I2C_READ_BIT);
   
  /* Read 2 bytes */
  firstByte = i2c_read(1);
  secondByte = i2c_read(0);
 
   i2c_stop(); // Moved from after DUBUG segment!!
 
  *value = ((int16)firstByte << 8) | (int16)secondByte;
 
  return error;
}





/*******************T731 FUNCTIONS******************************************/

/*******************************************************************
* DESCRIPTION :     Function to setup the thermometer to the highest 
*                   possible resolution (13 bits + sign)
*
* INPUTS : None
* OUTPUTS : None
*
* NOTES :           This function works for T731.
*/
void t731_setup()
{
      i2c_start ();
      i2c_write (T731_ADDR | I2C_WRITE_BIT);              // Bus address of the device, even address = write mode
      i2c_write (T731_STATUS_REG);                     // Address for control / status register in device
      i2c_write ((1 << T731_RES0) | (1 << T731_RES1)); // Set the temperature resolution two 13 bits + sign
      i2c_stop ();
}

/*******************************************************************
* DESCRIPTION :     Function used to read the temperature from T731 sensor.
*
* INPUTS : None
*
* OUTPUTS : returns a single measured temperature.
*
* NOTES : It's important to call t731_setup before.
*         Returns 0.0 in case of ERROR
*/
float t731_read_temperature()
{
  int error = FALSE;
  signed int16 iDataTemp = 0;
  int iConfigReg = 0;
  float fScaledReadTemp = 0.0;
  float fAverageMeasurement = 0.0;
 

  /* Set the oneshot bit to 1 too force the temp conversion */
  error |= read_i2c_int(T731_ADDR, T731_CONFIG_REG, &iConfigReg);
  iConfigReg |= (1 << CONFIG_REG_ONESHOT);
  error |= write_i2c(T731_ADDR, T731_CONFIG_REG, iConfigReg);
 
  /* Delay for the conversion can be done better with the while loop and bit polling */
  delay_ms(121);
 
  /* Read the temperature */
  error |= read_i2c_long(T731_ADDR, T731_TEMP_REG, &iDataTemp);
   
  /* Check for errors */
  if(error)
  {
    printf("ERROR in t731_read_temperature(), no ack on I2C bus!!! \n");      
    return (0.0);
  }
   
    /* Conversion */
    fScaledReadTemp += (((float)iDataTemp)/128.0);
    return  fScaledReadTemp;
}


 
 
/*******************************************************************
* DESCRIPTION :     Prints out the configuration register of T731
* INPUTS : None
*
* OUTPUTS : None
*
* NOTES : None
*/
void t731_read_configuration()
{
   int iReadData = 0;
   
   read_i2c_int(T731_ADDR, T731_STATUS_REG, &iReadData);
 
   printf("\nRead status register value: %u\n", iReadData);
}



/*******************EEPROM FUNCTIONS****************************************/

void write_ext_eeprom(int16 address, BYTE data)
{
  int8 status;
  i2c_start();
  i2c_write(0xa0); // i2c address for EEPROM, write mode
  i2c_write((address>>8)&0x1f); // MSB of data address, max 8 kB
  i2c_write(address); // LSB of data address
  i2c_write(data); // data byte written to EEPROM
  i2c_stop();
  // wait until EEPROM has finished writing
  i2c_start(); // restart
  status = i2c_write(0xa0); // get acknowledge from EEPROM
  while(status == 1) // no acknowledge received from EEPROM, so still busy
  {
    i2c_start();
    status=i2c_write(0xa0); // repeat while busy
  }
  i2c_stop();
}
 
BYTE read_ext_eeprom (int16 address)
{
  BYTE data;
  i2c_start();
  i2c_write(0xa0); // i2c address for EEPROM, write mode
  i2c_write((address>>8)&0x1f); // MSB of data address, max 8kB
  i2c_write(address); // LSB of data address
  i2c_start(); // Restart
  i2c_write(0xa1); // i2c address for EEPROM, read mode
  data=i2c_read(0); // read byte, send NACK
  i2c_stop();
  return(data);
}

void readEepromTemp()
{
  unsigned int16 i_eeprom_read_adr = 0;
  float fDigitalMeasurement;
  float fAnalogueMeasurement;
  
  printf("#\t\t\tDigital Measurement\t\t\tAnalogue Measurement\n");  
  //printf("%-5s%-25s%s\n", "#", "Digital Measurement", "Analogue Measurement");

  while(i_eeprom_write_adr != i_eeprom_read_adr)
  {
    float analog_temp, digital_temp;
    struct time_s time;
           
    float_convert.i  = ( (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 0) << 24);
    float_convert.i |= ( (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 1) << 16);
    float_convert.i |= ( (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 2) << 8);
    float_convert.i |=   (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 3);
    
    fDigitalMeasurement = float_convert.f;
    
    float_convert.i  = ( (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 4) << 24);
    float_convert.i |= ( (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 5) << 16);
    float_convert.i |= ( (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 6) << 8);
    float_convert.i |=   (unsigned int32) read_ext_eeprom(i_eeprom_read_adr * 14 + 7);
  
    fAnalogueMeasurement = float_convert.f;
    
    time.sec   = read_ext_eeprom(i_eeprom_read_adr * 14 + 8);
    time.min   = read_ext_eeprom(i_eeprom_read_adr * 14 + 9);
    time.hour  = read_ext_eeprom(i_eeprom_read_adr * 14 + 10);
    time.date  = read_ext_eeprom(i_eeprom_read_adr * 14 + 11);
    time.month = read_ext_eeprom(i_eeprom_read_adr * 14 + 12);
    time.year  = read_ext_eeprom(i_eeprom_read_adr * 14 + 13);
    
    printf("%Lu\t\t\t\%.2f\t\t\t\t\t%.2f\t", i_eeprom_read_adr, fDigitalMeasurement, fAnalogueMeasurement);
    printf("%u:%u:%u %u  %u %Lu \n", time.sec, time.min, time.hour, time.date, time.month, (int16)time.year + 2000);
    
    i_eeprom_read_adr++;          
  }
}

void writeEepromTemp(unsigned int32 digitalTemp, unsigned int32 analogueTemp, struct time_s time)
{
          write_ext_eeprom(i_eeprom_write_adr * 14 + 0, (BYTE) (digitalTemp >> 24) );
          write_ext_eeprom(i_eeprom_write_adr * 14 + 1, (BYTE) (digitalTemp >> 16) );
          write_ext_eeprom(i_eeprom_write_adr * 14 + 2, (BYTE) (digitalTemp >> 8) );
          write_ext_eeprom(i_eeprom_write_adr * 14 + 3, (BYTE) (digitalTemp) );
 
          write_ext_eeprom(i_eeprom_write_adr * 14 + 4, (BYTE) (analogueTemp >> 24) );
          write_ext_eeprom(i_eeprom_write_adr * 14 + 5, (BYTE) (analogueTemp >> 16) );
          write_ext_eeprom(i_eeprom_write_adr * 14 + 6, (BYTE) (analogueTemp >> 8) );
          write_ext_eeprom(i_eeprom_write_adr * 14 + 7, (BYTE) (analogueTemp) );
  
         printf("EEPROM write:     %u.%u.%u, %u:%u:%u\n" time.date, time.month, time.year, time.hour, time.min, time.sec);
              write_ext_eeprom(i_eeprom_write_adr * 14 + 8,  (BYTE) time.sec);
              write_ext_eeprom(i_eeprom_write_adr * 14 + 9,  (BYTE) time.min);
              write_ext_eeprom(i_eeprom_write_adr * 14 + 10, (BYTE) time.hour);
              write_ext_eeprom(i_eeprom_write_adr * 14 + 11, (BYTE) time.date);
              write_ext_eeprom(i_eeprom_write_adr * 14 + 12, (BYTE) time.month);
              write_ext_eeprom(i_eeprom_write_adr * 14 + 13, (BYTE) time.year);
}





/*******************GENERAL FUNCTIONS***************************************/


int8 BCDtoBIN(int8 x) { return(((x>>4)*10)+(x%16)); }
int8 BINtoBCD(int8 x) { return(((x/10)<<4)+(x%10)); }

/*******************************************************************
* DESCRIPTION :     Prints the temperature on LCD screen
* INPUTS : 
*                   fTempDigital - digital sensor temp
*                   fTempAnalog  - analogue sensor temp
*
* OUTPUTS : None
*
* NOTES : None
*/
void show_temperature(float fTempDigital, float fTempAnalog)
{
  char sTempDigital[17], sTempAnalog[17];
  sprintf(sTempDigital, "DIG TEMP: %.2f C", fTempDigital);
  sprintf(sTempAnalog,  "ANA TEMP: %.2f C", fTempAnalog);
 
  lcd_gotoxy(1,1);
  lcd_print(sTempDigital);
  lcd_gotoxy(1,2);
  lcd_print(sTempAnalog);  
}

void setupRTC(struct time_s in_time)
{
   //printf("DEBUG  %u.%u.%u, %u:%u:%u\n" in_time.date, in_time.month, in_time.year, in_time.hour, in_time.min, in_time.sec);  
  
   write_i2c(DS1430_ADDR, DS1430_SEC_REG,   (BINtoBCD(in_time.sec) & 0x7F) );
   write_i2c(DS1430_ADDR, DS1430_MIN_REG,   BINtoBCD(in_time.min));
   write_i2c(DS1430_ADDR, DS1430_HOUR_REG,  BINtoBCD(in_time.hour));
   write_i2c(DS1430_ADDR, DS1430_DATE_REG,  BINtoBCD(in_time.date));
   write_i2c(DS1430_ADDR, DS1430_MONTH_REG, BINtoBCD(in_time.month));
   write_i2c(DS1430_ADDR, DS1430_YEAR_REG,  BINtoBCD(in_time.year));
}

struct time_s readRtcTime()
{
  struct time_s in_time;
  
  int error = FALSE;
  // int read_i2c_int(int addr, int reg, int * value)
  error |= read_i2c_int(DS1430_ADDR,DS1430_SEC_REG,   &in_time.sec);
  error |= read_i2c_int(DS1430_ADDR,DS1430_MIN_REG,   &in_time.min);
  error |= read_i2c_int(DS1430_ADDR,DS1430_HOUR_REG,  &in_time.hour);
  error |= read_i2c_int(DS1430_ADDR,DS1430_DATE_REG,  &in_time.date);
  error |= read_i2c_int(DS1430_ADDR,DS1430_MONTH_REG, &in_time.month);
  error |= read_i2c_int(DS1430_ADDR,DS1430_YEAR_REG,  &in_time.year);
  
  /* Translate from BCD to BIN */
  in_time.sec   = BCDtoBIN(in_time.sec & 0x7F);
  in_time.min   = BCDtoBIN(in_time.min & 0x7F);
  in_time.hour  = BCDtoBIN(in_time.hour & 0x3F);
  in_time.date  = BCDtoBIN(in_time.date & 0x3F);
  in_time.month = BCDtoBIN(in_time.month & 0x1F);
  in_time.year  = BCDtoBIN(in_time.year & 0xFF);
  
  if(error)
  {
    printf("ERROR in readRtcTime!\n");
  }
  
  return in_time;
}








/*******************************************************************
* DESCRIPTION :     Function used to initialize the environment
*
* INPUTS : None
*
* OUTPUTS : None
*
* NOTES : None
*/
void init()
{
  setup_oscillator(OSC_8MHZ,2);
 
  /* Initialize the LCD screen */
  lcd_init();
  lcd_clear();
 
  // interrupt pin setup
  //port_b_pullups(TRUE);
  //ext_int_edge(H_TO_L);
 
  /* Setup pins C3 and C4  (for I2C) */
   output_float (PIN_C4);
   output_float (PIN_C3);
 
  /* Setup the  ADC */
  setup_vref (0xE2);
  setup_adc(ADC_CLOCK_DIV_32);
  setup_adc_ports (sAN6 | VSS_VREF);
  set_adc_channel (6);
     
  // interrupt setup
  //clear_interrupt(int_rda);  
  //enable_interrupts(int_rda);
  //enable_interrupts(global); 
  
  /* Setup the initial */
  setupRTC(initialTime);
}

/*******************************************************************
* DESCRIPTION :Clears the screen 
*
* INPUTS : None
*
* OUTPUTS : None
*
* NOTES : None
*/ 
void CLRScreen (){
    putc(0x1b); // <ESC> Clear display
    putc(0x5b); // [
    putc(0x32); // 2
    putc(0x4a); // J
    putc(0x1b); // <ESC> Reset cursor position 
    putc(0x5b); // [
    putc(0x30); // 0
    putc(0x3b); // ;
    putc(0x30); // 0
    putc(0x48); // H
}

/*******************************************************************
* DESCRIPTION :     Function used to display the help menu on screen
*
* INPUTS : None
*
* OUTPUTS : None
*
* NOTES : None
*/ 
/*void displayHelp()
{
    CLRScreen();
    printf("help menu \n");
    printf("1: Display this menu \n");
    printf("2: Enable log \n");
    printf("3: Disable log \n");
    printf("4: Set log interval\n");
    printf("5: Read log\n");
    printf("6: Delete log\n");
    printf("7: Set date and time in the RTC\n");
}
*/
/*******************************************************************
* DESCRIPTION : Cast a string to an int
*
* INPUTS : string to be casted
*
* OUTPUTS : casted int.
*
* NOTES : source: http://www.geeksforgeeks.org/write-your-own-atoi/
*/
/*
int myAtoi(char *str)
{
    int res = 0; // Initialize result
 
    // Iterate through all characters of input string and
    // update result
    for (int i = 0; str[i] != '\0'; ++i)
        res = res*10 + str[i] - '0';
 
    // return result.
    return res;
}
*/
/*******************************************************************
* DESCRIPTION :     Function used to read the temperature from the analogue sensor.
*
* INPUTS : None
*
* OUTPUTS : returns the measured temperature.
*
* NOTES : None
*/
float adc_read_temperature()
{
  unsigned int16 iAdcVal =0;
  float fAdcDegrees;
  
  // start the ADC for conversion
  read_adc(ADC_START_ONLY);
  
  // Poll on ADC result
  int1 done = adc_done();    
  while(!done)
  {
    // wait until measurement is ready
    done = adc_done();
  }
 
  // read conversion result
  iAdcVal = read_adc(ADC_READ_ONLY);
 
  // 1 LSB ~ 4mV  10mV = 1 deg C
  fAdcDegrees = ((float)iAdcVal*0.03964843750);

  // return the converted result
  return fAdcDegrees;
}


/* RTOS */
#use rtos(timer=1, minor_cycle=100ms)

#task(rate=100ms, max=90ms)
void digital_measure_task();

#task(rate=200ms, max=10ms)
void analogue_measure_task();

#task(rate=1000ms)
void display_task();

#task(rate=1000ms)
void logging_task();

#task(rate=200ms)
void key_task();


float fDigitalTempDisplay= 0.0f;
float fAnalogueTempDisplay= 0.0f;
float fDigitalTempLog = 0.0f;
float fAnalogueTempLog = 0.0f;
unsigned int16 iLoggingCount=0, iloggingInterval = 2;
unsigned int16 iAnalogueMeasCountLog;
unsigned int16 iAnalogueMeasCountDisplay;
unsigned int16 iDigitalMeasCountLog;
unsigned int16 iDigitalMeasCountDisplay;

void digital_measure_task()
{
    float localMeasurement;
    
    output_high(PIN_D0);
    localMeasurement = t731_read_temperature();
    output_low(PIN_D0);
  
    fDigitalTempLog += localMeasurement;
    fDigitalTempDisplay += localMeasurement;
  
    iDigitalMeasCountLog++;
    iDigitalMeasCountDisplay++;
}


void analogue_measure_task()
{
    float localMeasurement;
    localMeasurement = adc_read_temperature(); 
    
    fAnalogueTempLog += localMeasurement;
    fAnalogueTempDisplay += localMeasurement;
  
    iAnalogueMeasCountLog++;
    iAnalogueMeasCountDisplay++;
}


void display_task()
{
  // take the average measurement of the accumulated measurements. 
  fDigitalTempDisplay = fDigitalTempDisplay / (float)iDigitalMeasCountDisplay;
  fAnalogueTempDisplay = fAnalogueTempDisplay / (float)iAnalogueMeasCountDisplay;
  
  /* Show the temperature measurements on LCD */  
  show_temperature(fDigitalTempDisplay, fAnalogueTempDisplay);
  
  //printf("Analgue measurements %Lu, Digital measuremenets %Lu\n", iAnalogueMeasCountDisplay, iDigitalMeasCountDisplay);
  
  /* Reset variables */
  iDigitalMeasCountDisplay = 0;   
  fDigitalTempDisplay = 0.0f;
  iAnalogueMeasCountDisplay = 0;   
  fAnalogueTempDisplay = 0.0f;
}

void set_calendar()
{
           CLRScreen();
  
           printf("Enter day of month:\n");
           scanf("%u", &initialTime.date);
           printf("Enter month:\n");
           scanf("%u", &initialTime.month);
           printf("Enter year:\n");
           scanf("%u", &initialTime.year);
           printf("Enter hours:\n");
           scanf("%u", &initialTime.hour);
           printf("Enter minutes:\n");
           scanf("%u", &initialTime.min);
           printf("Enter seconds:\n");
           scanf("%u", &initialTime.sec);
  
           setupRTC(initialTime);
}

void key_task()
{
  if(kbhit())
  {
        switch(getc())
              {
                case '1': 
                        //displayHelp(); /* Display menu */
                break;
                case '2' : 
                        rtos_enable(logging_task);
                break;
                case '3': 
                        rtos_disable(logging_task);
                break;
                case '4' :
                   CLRScreen();
                   
                   printf("\nSelect the logging time interval:\n");
                   scanf("%d", &iloggingInterval);  /* Set logging delay */
        
                   if(iloggingInterval < 2 || iloggingInterval > 99)
                   {
                      printf("Selected logging time has to be in rage 2-99. Interval reset.\n");  
                      iloggingInterval = 2;
                   }
                   printf("Selected logging time [s]: %lu\n", iloggingInterval);
                break;
                case '7':
                  set_calendar();
                default:
                   printf("\nWarning: Unknown character pressed");
                break;              
              }  
  }
}


void logging_task()
{
  struct time_s currentTime;
  
  /* Read the current time from RTC */
  currentTime = readRtcTime();
  
  rtos_await(++iLoggingCount >= iLoggingInterval);      
  iLoggingCount=0;
  
  // take the average measurement of the accumulated measurements. 
  fDigitalTempLog = fDigitalTempLog / (float)iDigitalMeasCountLog;
  fAnalogueTempLog = fAnalogueTempLog / (float)iAnalogueMeasCountLog;
  
  //printf("%u.%u.%u, %u:%u:%u\n" currentTime.date, currentTime.month, currentTime.year, currentTime.hour, currentTime.min, currentTime.sec);
  printf("Logging: Analgue measurements %Lu, Digital measuremenets %Lu\n", iAnalogueMeasCountLog, iDigitalMeasCountLog);
  
  // reset the measurement counter
  iDigitalMeasCountLog = 0;   
  fDigitalTempLog = 0.0f;
  iAnalogueMeasCountLog = 0;   
  fAnalogueTempLog = 0.0f;
}


void main()
{

  /* Initialize the system */
  init();
  
  /* Setup the t371 */
  t731_setup();
  
  /* Run the RTOS */
  rtos_run();
  
  /*rtos_stats(measure_task,&stats);
   printf ( "\n\r" );
   printf ( "task_total_ticks : %Lius\n\r" ,
   (int32)(stats.task_total_ticks)*stats.hns_per_tick );
   printf ( "task_min_ticks : %Lius\n\r" ,
   (int32)(stats.task_min_ticks)*stats.hns_per_tick );
   printf ( "task_max_ticks : %Lius\n\r" ,
   (int32)(stats.task_max_ticks)*stats.hns_per_tick );
  printf ("\n\r"); */
}
