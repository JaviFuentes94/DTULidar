CCS PCM C Compiler, Version 5.026, 18875               03-dec-17 19:51

               Filename:   C:\Users\User\Google Drev\DTU Elektro\5. semester\Digital Instrumentering\30021_project\DTULidar\Complete\main.lst

               ROM used:   397 words (5%)
                           Largest free fragment is 2048
               RAM used:   22 (6%) at main() level
                           31 (9%) worst case
               Stack used: 3 locations
               Stack size: 7

*
0000:  NOP
0001:  MOVLW  01
0002:  MOVWF  0A
0003:  GOTO   12F
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  05
0009:  RETLW  09
000A:  RETLW  0A
000B:  RETLW  06
....................  
.................... #list 
....................  
.................... #device ICD=true 
.................... #device ADC=10 
....................   
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................   
.................... #use delay(internal=8000000,clock_out) 
*
00C8:  MOVLW  31
00C9:  MOVWF  04
00CA:  BCF    03.7
00CB:  MOVF   00,W
00CC:  BTFSC  03.2
00CD:  GOTO   0DB
00CE:  MOVLW  02
00CF:  MOVWF  78
00D0:  CLRF   77
00D1:  DECFSZ 77,F
00D2:  GOTO   0D1
00D3:  DECFSZ 78,F
00D4:  GOTO   0D0
00D5:  MOVLW  97
00D6:  MOVWF  77
00D7:  DECFSZ 77,F
00D8:  GOTO   0D7
00D9:  DECFSZ 00,F
00DA:  GOTO   0CE
00DB:  BCF    0A.3
00DC:  BCF    0A.4
00DD:  GOTO   176 (RETURN)
....................   
.................... #use rs232( baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8, ERRORS) 
....................   
.................... //#use RS232 (DEBUGGER) 
....................   
.................... //#use  I2C(master, sda=PIN_C4, scl= PIN_C3) 
....................  
....................  
.................... #include "lib/stepperControl.c" 
.................... #include "stepperControl.h" 
.................... #ifndef stepperControl 
.................... #define stepperControl 
....................  
.................... /*Defines*/ 
.................... #define BOTTOM_MOTOR 0  
.................... #define TOP_MOTOR 1 
.................... #define BOTTOM_MOTOR_LIMIT 20 
.................... #define TOP_MOTOR_LIMIT 30 
.................... #BYTE portc = 7      // Port used to control motor 
.................... #BYTE portd = 8      // PIC16F887 datasheet page 25 
....................  
.................... /* Globals */ 
.................... BYTE const POSITIONS[4] = { 0b0101, 0b1001, 0b1010, 0b0110 }; 
.................... unsigned int8 iCurrentState[2] = { 0 }; /* This variable keeps track of the current state */ 
*
015E:  BCF    03.6
015F:  CLRF   21
0160:  CLRF   22
.................... unsigned int32 iDelay = 5000; // delay default 5ms 
.................... signed int8 iGlobalPosition[2] = { 0 }; 
0161:  CLRF   27
0162:  CLRF   28
.................... int1  bSequenceOver = FALSE; 
.................... int1  bGlobalGoRight = FALSE; 
....................  
.................... /* Function declarations */ 
.................... void initStepper(void); 
.................... void stepperRotateSingleRight(int motor); 
.................... void stepperRotateSingleLeft(int motor); 
.................... int16 moveMeasure(int measureTime_ms, int rotation); 
.................... void stepperRotate180right(int timeDelay_us, int motor); 
.................... void stepperRotate180left(int timeDelay_us, int motor); 
.................... void stepperMotorSequenceTop(void); 
.................... void stepperMotorSequence(signed int8 * angleX, signed int8 * angleZ); 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... void initStepper() 
.................... { 
....................    set_tris_c(0xF0); 
*
000C:  MOVLW  F0
000D:  BSF    03.5
000E:  MOVWF  07
000F:  BCF    03.5
0010:  MOVWF  2A
....................    set_tris_d(0xF0); 
0011:  BSF    03.5
0012:  MOVWF  08
0013:  BCF    03.5
0014:  BCF    0A.3
0015:  BCF    0A.4
0016:  GOTO   16B (RETURN)
.................... } 
....................  
.................... void stepperMotorSequenceTop() 
.................... { 
....................    stepperRotateSingleRight(TOP_MOTOR); 
*
0060:  MOVLW  01
0061:  MOVWF  35
0062:  CALL   037
....................    iGlobalPosition[TOP_MOTOR]++; 
0063:  INCF   28,F
....................    bGlobalGoRight = !bGlobalGoRight; 
0064:  MOVLW  02
0065:  XORWF  29,F
....................  
....................    if(iGlobalPosition[TOP_MOTOR] == TOP_MOTOR_LIMIT) 
0066:  MOVF   28,W
0067:  SUBLW  1E
0068:  BTFSC  03.2
....................    { 
....................       bSequenceOver = True; 
0069:  BSF    29.0
....................    } 
006A:  RETURN
.................... } 
....................  
.................... void stepperMotorSequence(signed int8 * angleX, signed int8 * angleZ) 
.................... { 
....................    if(bSequenceOver) 
006B:  BTFSC  29.0
....................    { 
....................       return; 
006C:  GOTO   0C5
....................    } 
....................  
....................    if(bGlobalGoRight == TRUE) 
006D:  BTFSS  29.1
006E:  GOTO   079
....................    { 
....................       if(iGlobalPosition[BOTTOM_MOTOR] == BOTTOM_MOTOR_LIMIT) 
006F:  MOVF   27,W
0070:  SUBLW  14
0071:  BTFSS  03.2
0072:  GOTO   075
....................       { 
....................          stepperMotorSequenceTop(); 
0073:  CALL   060
....................       } 
0074:  GOTO   078
....................       else 
....................       { 
....................          stepperRotateSingleRight(BOTTOM_MOTOR);       
0075:  CLRF   35
0076:  CALL   037
....................          iGlobalPosition[BOTTOM_MOTOR]++;          
0077:  INCF   27,F
....................       } 
....................    } 
0078:  GOTO   0B7
....................    else 
....................    { 
....................       if(iGlobalPosition[BOTTOM_MOTOR] == (-1*BOTTOM_MOTOR_LIMIT)) 
0079:  MOVF   27,W
007A:  SUBLW  EC
007B:  BTFSS  03.2
007C:  GOTO   07F
....................       { 
....................          stepperMotorSequenceTop(); 
007D:  CALL   060
....................       } 
007E:  GOTO   0B7
....................       else 
....................       { 
....................          stepperRotateSingleLeft(BOTTOM_MOTOR);       
007F:  CLRF   35
....................          iGlobalPosition[BOTTOM_MOTOR]--;                
*
00B6:  DECF   27,F
....................       } 
....................    } 
....................     
....................    *angleZ = iGlobalPosition[BOTTOM_MOTOR]; 
00B7:  MOVF   33,W
00B8:  MOVWF  04
00B9:  BCF    03.7
00BA:  BTFSC  34.0
00BB:  BSF    03.7
00BC:  MOVF   27,W
00BD:  MOVWF  00
....................    *angleX = iGlobalPosition[TOP_MOTOR]; 
00BE:  MOVF   31,W
00BF:  MOVWF  04
00C0:  BCF    03.7
00C1:  BTFSC  32.0
00C2:  BSF    03.7
00C3:  MOVF   28,W
00C4:  MOVWF  00
00C5:  BCF    0A.3
00C6:  BCF    0A.4
00C7:  GOTO   173 (RETURN)
.................... } 
....................  
.................... void stepperRotateSingleRight(int1 motor) 
.................... { 
....................    iCurrentState[motor] = ((iCurrentState[motor]+1)&3); 
*
0037:  MOVLW  21
0038:  ADDWF  35,W
0039:  MOVWF  78
003A:  CLRF   7A
003B:  BTFSC  03.0
003C:  INCF   7A,F
003D:  MOVLW  21
003E:  ADDWF  35,W
003F:  MOVWF  04
0040:  BCF    03.7
0041:  MOVLW  01
0042:  ADDWF  00,W
0043:  ANDLW  03
0044:  MOVWF  38
0045:  MOVF   78,W
0046:  MOVWF  04
0047:  BCF    03.7
0048:  BTFSC  7A.0
0049:  BSF    03.7
004A:  MOVF   38,W
004B:  MOVWF  00
....................       
....................      /* Set outputs to move the motor */ 
....................    if(motor == 1) 
004C:  DECFSZ 35,W
004D:  GOTO   057
....................    { 
....................       portc = POSITIONS[iCurrentState[motor]]; 
004E:  MOVLW  21
004F:  ADDWF  35,W
0050:  MOVWF  04
0051:  BCF    03.7
0052:  MOVF   00,W
0053:  CALL   004
0054:  MOVWF  78
0055:  MOVWF  07
....................    } 
0056:  GOTO   05F
....................    else 
....................    { 
....................       portd = POSITIONS[iCurrentState[motor]]; 
0057:  MOVLW  21
0058:  ADDWF  35,W
0059:  MOVWF  04
005A:  BCF    03.7
005B:  MOVF   00,W
005C:  CALL   004
005D:  MOVWF  78
005E:  MOVWF  08
....................    }         
005F:  RETURN
.................... } 
....................  
.................... void stepperRotateSingleLeft(int1 motor) 
.................... { 
....................    if(iCurrentState[motor] == 0) 
*
0080:  MOVLW  21
0081:  ADDWF  35,W
0082:  MOVWF  04
0083:  BCF    03.7
0084:  MOVF   00,F
0085:  BTFSS  03.2
0086:  GOTO   08E
....................    { 
....................       iCurrentState[motor] = 3; 
0087:  MOVLW  21
0088:  ADDWF  35,W
0089:  MOVWF  04
008A:  BCF    03.7
008B:  MOVLW  03
008C:  MOVWF  00
....................    } 
008D:  GOTO   0A3
....................    else 
....................    { 
....................       iCurrentState[motor] = ((iCurrentState[motor]-1)&3); 
008E:  MOVLW  21
008F:  ADDWF  35,W
0090:  MOVWF  78
0091:  CLRF   7A
0092:  BTFSC  03.0
0093:  INCF   7A,F
0094:  MOVLW  21
0095:  ADDWF  35,W
0096:  MOVWF  04
0097:  BCF    03.7
0098:  MOVLW  01
0099:  SUBWF  00,W
009A:  ANDLW  03
009B:  MOVWF  38
009C:  MOVF   78,W
009D:  MOVWF  04
009E:  BCF    03.7
009F:  BTFSC  7A.0
00A0:  BSF    03.7
00A1:  MOVF   38,W
00A2:  MOVWF  00
....................    } 
....................    if(motor == 1) 
00A3:  DECFSZ 35,W
00A4:  GOTO   0AE
....................    { 
....................       portc = POSITIONS[iCurrentState[motor]]; 
00A5:  MOVLW  21
00A6:  ADDWF  35,W
00A7:  MOVWF  04
00A8:  BCF    03.7
00A9:  MOVF   00,W
00AA:  CALL   004
00AB:  MOVWF  78
00AC:  MOVWF  07
....................    } 
00AD:  GOTO   0B6
....................    else 
....................    { 
....................       portd = POSITIONS[iCurrentState[motor]]; 
00AE:  MOVLW  21
00AF:  ADDWF  35,W
00B0:  MOVWF  04
00B1:  BCF    03.7
00B2:  MOVF   00,W
00B3:  CALL   004
00B4:  MOVWF  78
00B5:  MOVWF  08
....................    } 
....................  
.................... }    
....................  
.................... #include "lib/sensorControl.c" 
.................... #include "sensorControl.h" 
.................... #ifndef sensorControl 
.................... #define sensorControl 
....................  
.................... /*Defines*/ 
.................... #define CHANNEL_LONG_RANGE  4 
.................... #define CHANNEL_SHORT_RANGE 6 
....................  
.................... /*Function declarations*/ 
.................... void initSensors(void); 
.................... unsigned int16 readInternalAdc(unsigned int8 channel); 
.................... float readLongRangeSensor(); 
.................... float readShortRangeSensor(); 
.................... float readRangeSensor(); 
....................  
.................... #endif 
....................  
....................  
.................... void initSensors() 
.................... { 
....................   /* Setup the  ADC to 2.5V */ 
....................   //setup_vref(VREF_LOW | 0x0C); 
....................   setup_vref(0xEC); 
*
0017:  MOVLW  EC
0018:  BSF    03.5
0019:  MOVWF  17
....................   setup_adc(ADC_CLOCK_DIV_32); 
001A:  BCF    03.5
001B:  BCF    1F.6
001C:  BSF    1F.7
001D:  BSF    03.5
001E:  BSF    1F.7
001F:  BCF    03.5
0020:  BSF    1F.0
....................   setup_adc_ports (sAN4 | sAN6 | VSS_VREF); 
0021:  BSF    03.5
0022:  BSF    03.6
0023:  MOVF   09,W
0024:  ANDLW  C0
0025:  MOVWF  09
0026:  BCF    03.6
0027:  BSF    1F.4
0028:  BCF    1F.5
0029:  MOVLW  50
002A:  BSF    03.6
002B:  MOVWF  08
....................     
....................   /* Initially start with channel 6 */ 
....................   set_adc_channel(6); 
002C:  MOVLW  18
002D:  MOVWF  78
002E:  BCF    03.5
002F:  BCF    03.6
0030:  MOVF   1F,W
0031:  ANDLW  C3
0032:  IORWF  78,W
0033:  MOVWF  1F
0034:  BCF    0A.3
0035:  BCF    0A.4
0036:  GOTO   16C (RETURN)
.................... } 
....................  
.................... float readRangeSensor() 
.................... { 
....................    float fShortMeasRange = readShortRangeSensor(); 
....................    float fLongMeasRange = readLongRangeSensor(); 
....................     
....................    if(fShortMeasRange == 150) 
....................    { 
....................       return fLongMeasRange; 
....................    } 
....................    else 
....................    { 
....................       return fShortMeasRange; 
....................    } 
.................... } 
....................  
.................... unsigned int16 readInternalAdc(unsigned int8 channel) 
.................... { 
....................   set_adc_channel(channel); 
....................   delay_us(20); 
....................  
....................   read_adc(ADC_START_ONLY); // start the ADC for conversion 
....................    
....................   int1 done = adc_done();   // Poll on ADC result 
....................   while(!done)  
....................   { 
....................     // wait until measurement is ready 
....................     done = adc_done(); 
....................   } 
....................    
....................   // read conversion result 
....................   return((int16)read_adc(ADC_READ_ONLY)); 
.................... } 
....................  
.................... float readLongRangeSensor() 
.................... { 
....................   unsigned int16 iSensorRead; 
....................   float fSensorRead; 
....................   float fCumulativeMeasurement = 0.0f; 
....................    
....................   for(int i = 0; i <10; i++) 
....................   { 
....................      iSensorRead = readInternalAdc(CHANNEL_LONG_RANGE); 
....................    
....................      if(iSensorRead >= 940) 
....................      { 
....................       fSensorRead = 0; 
....................       } 
....................       else 
....................      { 
....................          if(iSensorRead <= 630 ) 
....................          { 
....................             fSensorRead = 500; 
....................          } 
....................          else 
....................          { 
....................          fSensorRead = 122f / (( 2.5f * ((float) iSensorRead) ) / 1024f - 1.28f); 
....................    //      printf("iSensorRead: %Lu \t in volt: %f \t\t", iSensorRead, (iSensorRead * 2.5f) / 1024f ); 
....................        } 
....................      } 
....................       
....................      fCumulativeMeasurement += fSensorRead;  
....................    } 
....................    
....................    return (fCumulativeMeasurement/10.0f); 
.................... } 
....................  
.................... float readShortRangeSensor() 
.................... { 
....................   unsigned int16 iSensorRead; 
....................   float fSensorRead; 
....................   float fCumulativeMeasurement = 0; 
....................    
....................   for(int i = 0; i<10; i++) 
....................   { 
....................    iSensorRead = readInternalAdc(CHANNEL_SHORT_RANGE); 
....................    // measurement below 30cm 
....................    if(iSensorRead >= 724 ) 
....................    { 
....................       fSensorRead = 30; 
....................    } 
....................    else  
....................    { 
....................       // measurement above 150 
....................       if( iSensorRead <= 204 ) 
....................          fSensorRead = 150; 
....................       else 
....................          fSensorRead = 50f / (( 2.5f * ((float) iSensorRead) ) / 1024f - 0.1f);  
....................    } 
....................    fCumulativeMeasurement += fSensorRead; 
....................   } 
....................    
....................   return fCumulativeMeasurement; 
.................... } 
....................  
....................  
....................  
.................... void sendMeasurements(signed int8 zAngle, signed int8 yAngle, float distance) 
.................... { 
....................    char characterToSend; 
....................    characterToSend = *((char*)&(zAngle)); 
*
00DE:  CLRF   39
00DF:  MOVLW  31
00E0:  MOVWF  38
00E1:  MOVF   38,W
00E2:  MOVWF  04
00E3:  BCF    03.7
00E4:  BTFSC  39.0
00E5:  BSF    03.7
00E6:  MOVF   00,W
00E7:  MOVWF  37
....................    putc((int)characterToSend); 
00E8:  MOVF   37,W
00E9:  BTFSS  0C.4
00EA:  GOTO   0E9
00EB:  MOVWF  19
....................     
....................    characterToSend = *((char*)&(yAngle)); 
00EC:  CLRF   39
00ED:  MOVLW  32
00EE:  MOVWF  38
00EF:  MOVF   38,W
00F0:  MOVWF  04
00F1:  BCF    03.7
00F2:  BTFSC  39.0
00F3:  BSF    03.7
00F4:  MOVF   00,W
00F5:  MOVWF  37
....................    putc((int)characterToSend); 
00F6:  MOVF   37,W
00F7:  BTFSS  0C.4
00F8:  GOTO   0F7
00F9:  MOVWF  19
....................     
....................    characterToSend = *(((char*)&(distance))+3); 
00FA:  CLRF   7A
00FB:  MOVLW  36
00FC:  MOVWF  04
00FD:  BCF    03.7
00FE:  BTFSC  7A.0
00FF:  BSF    03.7
0100:  MOVF   00,W
0101:  MOVWF  37
....................    //printf("First byte: %x", (int)characterToSend); 
....................    putc((int)characterToSend); 
0102:  MOVF   37,W
0103:  BTFSS  0C.4
0104:  GOTO   103
0105:  MOVWF  19
....................    characterToSend = *(((char*)&(distance))+2); 
0106:  CLRF   7A
0107:  MOVLW  35
0108:  MOVWF  04
0109:  BCF    03.7
010A:  BTFSC  7A.0
010B:  BSF    03.7
010C:  MOVF   00,W
010D:  MOVWF  37
....................    //printf("Sec byte: %x", (int)characterToSend); 
....................    putc((int)characterToSend); 
010E:  MOVF   37,W
010F:  BTFSS  0C.4
0110:  GOTO   10F
0111:  MOVWF  19
....................    characterToSend = *(((char*)&(distance))+1); 
0112:  CLRF   7A
0113:  MOVLW  34
0114:  MOVWF  04
0115:  BCF    03.7
0116:  BTFSC  7A.0
0117:  BSF    03.7
0118:  MOVF   00,W
0119:  MOVWF  37
....................    //printf("Third byte: %x", (int)characterToSend); 
....................    putc((int)characterToSend); 
011A:  MOVF   37,W
011B:  BTFSS  0C.4
011C:  GOTO   11B
011D:  MOVWF  19
....................    characterToSend = *((char*)&(distance)); 
011E:  CLRF   39
011F:  MOVLW  33
0120:  MOVWF  38
0121:  MOVF   38,W
0122:  MOVWF  04
0123:  BCF    03.7
0124:  BTFSC  39.0
0125:  BSF    03.7
0126:  MOVF   00,W
0127:  MOVWF  37
....................    //printf("Fourth byte: %x", (int)characterToSend); 
....................    putc((int)characterToSend); 
0128:  MOVF   37,W
0129:  BTFSS  0C.4
012A:  GOTO   129
012B:  MOVWF  19
012C:  BCF    0A.3
012D:  BCF    0A.4
012E:  GOTO   18B (RETURN)
.................... } 
....................  
....................  
.................... void main() 
012F:  MOVF   03,W
0130:  ANDLW  1F
0131:  MOVWF  03
0132:  MOVLW  71
0133:  BSF    03.5
0134:  MOVWF  0F
0135:  CLRF   10
0136:  MOVF   0F,W
0137:  BCF    03.5
0138:  CLRF   20
0139:  BSF    03.5
013A:  BSF    03.6
013B:  BCF    07.3
013C:  MOVLW  0C
013D:  BCF    03.6
013E:  MOVWF  19
013F:  MOVLW  A2
0140:  MOVWF  18
0141:  MOVLW  90
0142:  BCF    03.5
0143:  MOVWF  18
0144:  CLRF   26
0145:  CLRF   25
0146:  MOVLW  13
0147:  MOVWF  24
0148:  MOVLW  88
0149:  MOVWF  23
014A:  BCF    29.0
014B:  BCF    29.1
014C:  MOVLW  FF
014D:  MOVWF  2A
014E:  BSF    03.5
014F:  BSF    03.6
0150:  MOVF   09,W
0151:  ANDLW  C0
0152:  MOVWF  09
0153:  BCF    03.6
0154:  BCF    1F.4
0155:  BCF    1F.5
0156:  MOVLW  00
0157:  BSF    03.6
0158:  MOVWF  08
0159:  BCF    03.5
015A:  CLRF   07
015B:  CLRF   08
015C:  CLRF   09
015D:  BCF    03.7
.................... { 
....................    /* Declarations */ 
....................    float fRangeMeasurement; 
....................    signed int8 iAngleZ, iAngleX; 
....................  
....................       /* Initialize hardware */ 
....................       setup_oscillator(OSC_8MHZ,2); 
*
0163:  MOVLW  71
0164:  BSF    03.5
0165:  MOVWF  0F
0166:  MOVLW  02
0167:  MOVWF  10
0168:  MOVF   0F,W
....................       initStepper(); 
0169:  BCF    03.5
016A:  GOTO   00C
....................       initSensors(); 
016B:  GOTO   017
....................  
....................       while(TRUE) 
....................       { 
....................          /* Move the motor and recieve motors positions */ 
....................          stepperMotorSequence(&iAngleX, &iAngleZ); 
016C:  CLRF   32
016D:  MOVLW  30
016E:  MOVWF  31
016F:  CLRF   34
0170:  MOVLW  2F
0171:  MOVWF  33
0172:  GOTO   06B
....................          /* Wait for the motor to settle */ 
....................          delay_ms(50); 
0173:  MOVLW  32
0174:  MOVWF  31
0175:  GOTO   0C8
....................          /* Read the sensor value */ 
....................          //fRangeMeasurement = readRangeSensor(); 
....................          fRangeMeasurement = 121.21; 
0176:  MOVLW  85
0177:  MOVWF  2E
0178:  MOVLW  6B
0179:  MOVWF  2D
017A:  MOVLW  72
017B:  MOVWF  2C
017C:  MOVLW  85
017D:  MOVWF  2B
....................          /* Send the measurements to the PC */ 
....................          sendMeasurements(iAngleX, iAngleZ, fRangeMeasurement); 
017E:  MOVF   30,W
017F:  MOVWF  31
0180:  MOVF   2F,W
0181:  MOVWF  32
0182:  MOVF   2E,W
0183:  MOVWF  36
0184:  MOVF   2D,W
0185:  MOVWF  35
0186:  MOVF   2C,W
0187:  MOVWF  34
0188:  MOVF   2B,W
0189:  MOVWF  33
018A:  GOTO   0DE
018B:  GOTO   16C
....................          //printf("%f\n", fRangeMeasurement); 
....................      } 
....................     
.................... } 
018C:  GOTO   18C

Configuration Fuses:
   Word  1: 0CF5   INTRC NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP DEBUG
   Word  2: 3FFF   BORV40 NOWRT

   Some fuses have been forced to be compatible with the ICD debugger.
