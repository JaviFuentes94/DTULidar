CCS PCM C Compiler, Version 5.026, 18875               03-dec-17 12:42

               Filename:   C:\Users\User\Google Drev\DTU Elektro\5. semester\Digital Instrumentering\30021_project\DTULidar\Stepper Test\main.lst

               ROM used:   117 words (1%)
                           Largest free fragment is 2048
               RAM used:   12 (3%) at main() level
                           13 (4%) worst case
               Stack used: 1 locations
               Stack size: 7

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   03C
....................  
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  05
0009:  RETLW  09
000A:  RETLW  0A
000B:  RETLW  06
....................  
.................... #list 
....................  
.................... #device ICD=true 
.................... #device ADC=10 
....................   
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................   
.................... #use delay(internal=8000000,clock_out) 
*
0026:  MOVLW  27
0027:  MOVWF  04
0028:  BCF    03.7
0029:  MOVF   00,W
002A:  BTFSC  03.2
002B:  GOTO   039
002C:  MOVLW  02
002D:  MOVWF  78
002E:  CLRF   77
002F:  DECFSZ 77,F
0030:  GOTO   02F
0031:  DECFSZ 78,F
0032:  GOTO   02E
0033:  MOVLW  97
0034:  MOVWF  77
0035:  DECFSZ 77,F
0036:  GOTO   035
0037:  DECFSZ 00,F
0038:  GOTO   02C
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   071 (RETURN)
....................   
.................... //#use rs232( baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8, ERRORS) 
....................   
.................... #use RS232 (DEBUGGER) 
....................   
.................... //#use  I2C(master, sda=PIN_C4, scl= PIN_C3) 
....................  
....................  
.................... #include "lib/stepperControl.c" 
.................... #include "stepperControl.h" 
.................... #ifndef stepperControl 
.................... #define stepperControl 
....................  
.................... /*Declarations*/ 
.................... #BYTE portc = 7            // Port used to control motor 
.................... #BYTE portd = 8      // PIC16F887 datasheet page 25 
.................... BYTE const POSITIONS[4] = { 0b0101, 0b1001, 0b1010, 0b0110 }; 
.................... unsigned int8 iCurrentPosition = 0; /* This variable keeps track of the current position */ 
.................... unsigned int32 iDelay = 5000; // delay default 5ms 
....................  
.................... void initStepper(void); 
.................... void stepperRotateSingleRight(int motor); 
.................... void stepperRotateSingleLeft(int motor); 
.................... int16 moveMeasure(int measureTime_ms, int rotation); 
.................... void stepperRotate180right(int timeDelay_us, int motor); 
.................... void stepperRotate180left(int timeDelay_us, int motor); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void initStepper() 
.................... { 
....................    set_tris_c(0xF0); 
*
000C:  MOVLW  F0
000D:  BSF    03.5
000E:  MOVWF  07
000F:  BCF    03.5
0010:  MOVWF  25
0011:  BCF    0A.3
0012:  BCF    0A.4
0013:  GOTO   069 (RETURN)
.................... } 
....................  
....................  
.................... void stepperRotateSingleRight(int motor) 
.................... { 
....................      iCurrentPosition = ((iCurrentPosition+1)&3); 
0014:  MOVLW  01
0015:  ADDWF  20,W
0016:  ANDLW  03
0017:  MOVWF  20
....................       
....................      /* Set outputs to move the motor */ 
....................    if(motor == 1) 
0018:  DECFSZ 26,W
0019:  GOTO   01F
....................    { 
....................       portc = POSITIONS[iCurrentPosition]; 
001A:  MOVF   20,W
001B:  CALL   004
001C:  MOVWF  78
001D:  MOVWF  07
....................    } 
001E:  GOTO   023
....................    else 
....................    { 
....................       portd = POSITIONS[iCurrentPosition]; 
001F:  MOVF   20,W
0020:  CALL   004
0021:  MOVWF  78
0022:  MOVWF  08
....................    }    
0023:  BCF    0A.3
0024:  BCF    0A.4
0025:  GOTO   06C (RETURN)
....................       
.................... } 
....................  
.................... void stepperRotateSingleLeft(int motor) 
.................... { 
....................    if(iCurrentPosition == 0) 
....................    { 
....................       iCurrentPosition = 3; 
....................    } 
....................    else 
....................    { 
....................       iCurrentPosition = ((iCurrentPosition-1)&3); 
....................    } 
....................    if(motor == 1) 
....................    { 
....................       portc = POSITIONS[iCurrentPosition]; 
....................    } 
....................    else 
....................    { 
....................       portd = POSITIONS[iCurrentPosition]; 
....................    } 
....................  
.................... }    
.................... /* 
.................... int16 moveMeasure(int measureTime_ms, int rotation) 
.................... { 
....................       delay_ms(measureTime_ms); 
....................       int16 measurement = readLongRangeSensor(); 
....................       if(rotation == TRUE) 
....................       { 
....................             stepperRotateSingleRight(); 
....................       } 
....................       else    
....................       { 
....................             stepperRotateSingleLeft(); 
....................       }    
....................       return measurement; 
.................... }*/ 
....................  
.................... void stepperRotate180right(int timeDelay_us, int motor) 
.................... { 
....................     for(unsigned int8 i = 1; i<=100; i++) 
....................     { 
....................       if(motor == 1) 
....................       { 
....................          portc = POSITIONS[((iCurrentPosition + i)&3)]; 
....................       } 
....................       else 
....................       { 
....................          portd = POSITIONS[((iCurrentPosition + i)&3)]; 
....................       } 
....................         delay_us(timeDelay_us); 
....................     } 
.................... } 
....................  
....................  
.................... void stepperRotate180left(int timeDelay_us, int motor) 
.................... { 
....................    for(unsigned int8 i = 1; i<=100; i++) 
....................    { 
....................       if(iCurrentPosition == 0) 
....................       { 
....................          iCurrentPosition = 3; 
....................       } 
....................       else 
....................       { 
....................          iCurrentPosition = ((iCurrentPosition-1)&3); 
....................       } 
....................       if(motor == 1) 
....................       { 
....................          portc = POSITIONS[iCurrentPosition]; 
....................       }         
....................       else 
....................       { 
....................          delay_us(timeDelay_us); 
....................       } 
....................    } 
.................... } 
....................  
....................  
....................  
....................  
.................... //////////////////////////////////////////////////////////////////// 
.................... /* 
....................  
.................... #define CHANNEL_LONG_RANGE  4 
.................... #define CHANNEL_SHORT_RANGE 6 
....................  
.................... float rescaleLongRangeSensor(unsigned int16 adcValue) 
.................... { 
....................   float rescaledValue = 0.0; 
....................    
....................   if(adcValue >= 1000) 
....................   { 
....................       rescaledValue = 0.0; 
....................   } 
....................   else if(adcValue <= 573) 
....................   { 
....................       rescaledValue = 5.0; 
....................   } 
....................   else 
....................   { 
....................       rescaledValue = 122.0f / (( 2.5f * ((float) adcValue) ) / 1024f - 1.28f); 
....................   }   
....................   return rescaledValue; 
.................... } 
....................  
.................... unsigned int16 readInternalAdc(unsigned int8 channel) 
.................... { 
....................   set_adc_channel(channel); 
....................   delay_us(20); 
....................  
....................   read_adc(ADC_START_ONLY); // start the ADC for conversion 
....................    
....................   int1 done = adc_done();   // Poll on ADC result 
....................   while(!done)  
....................   { 
....................     // wait until measurement is ready 
....................     done = adc_done(); 
....................   } 
....................    
....................   // read conversion result 
....................   return((int16)read_adc(ADC_READ_ONLY)); 
.................... } 
....................  
.................... //unsigned int16 readLongRangeSensor() 
.................... float readLongRangeSensor() 
.................... { 
....................   unsigned int16 iSensorRead; 
....................   float rescaledValue; 
....................   iSensorRead = readInternalAdc(CHANNEL_LONG_RANGE); 
....................   rescaledValue = rescaleLongRangeSensor(iSensorRead); 
....................   printf("Original value: %Lu   Rescaled value: %f\n", iSensorRead, rescaledValue); 
....................   return rescaledValue; 
.................... } 
....................  
.................... unsigned int16 readShortRangeSensor() 
.................... { 
....................   unsigned int16 iSensorRead; 
....................   iSensorRead = readInternalAdc(CHANNEL_SHORT_RANGE); 
....................   /* Add conversion formulas here  
....................   return iSensorRead; 
.................... } 
....................  
.................... */ 
....................  
.................... /* 
.................... void init() 
.................... { 
.................... //  setup_oscillator(OSC_8MHZ,2); 
....................   
....................   // Setup the  ADC to 2.5V  
....................   //setup_vref(VREF_LOW | 0x0C); 
....................    setup_vref(0xEC); 
....................   setup_adc(ADC_CLOCK_DIV_32); 
....................   setup_adc_ports (sAN4 | sAN6 | VSS_VREF); 
....................     
....................   //Initially start with channel 6  
....................   set_adc_channel(6); 
.................... } 
.................... */ 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void initStepper() 
.................... { 
....................    set_tris_c(0xF0); 
.................... } 
....................  
....................  
.................... void stepperRotateSingleRight() 
.................... { 
....................      iCurrentPosition = ((iCurrentPosition+1)&3); 
....................       
....................      portc = POSITIONS[iCurrentPosition]; 
.................... } 
....................  
.................... void stepperRotateSingleLeft() 
.................... { 
....................      if(iCurrentPosition == 0) 
....................      { 
....................          iCurrentPosition = 3; 
....................      } 
....................      else 
....................      { 
....................          iCurrentPosition = ((iCurrentPosition-1)&3); 
....................      } 
....................      portc = POSITIONS[iCurrentPosition]; 
.................... } 
....................  
.................... int16 moveMeasure(int measureTime_ms, int rotation) 
.................... { 
....................       delay_ms(measureTime_ms); 
....................       int16 measurement = readLongRangeSensor(); 
....................       if(rotation == TRUE) 
....................       { 
....................             stepperRotateSingleRight(); 
....................       } 
....................       else    
....................       { 
....................             stepperRotateSingleLeft(); 
....................       }    
....................       return measurement; 
.................... } 
....................  
.................... void stepperRotate180right(int timeDelay_us) 
.................... { 
....................       for(unsigned int8 i = 1; i<=100; i++) 
....................     { 
....................        portc = POSITIONS[((iCurrentPosition + i)&3)]; 
....................       delay_us(timeDelay_us); 
....................     } 
.................... } 
....................  
....................  
.................... void stepperRotate180left(int timeDelay_us) 
.................... { 
....................       for(unsigned int8 i = 1; i<=100; i++) 
....................     { 
....................        if(iCurrentPosition == 0) 
....................        { 
....................            iCurrentPosition = 3; 
....................        } 
....................        else 
....................        { 
....................            iCurrentPosition = ((iCurrentPosition-1)&3); 
....................        } 
....................        portc = POSITIONS[iCurrentPosition]; 
....................           delay_us(timeDelay_us); 
....................     } 
.................... } 
....................  
.................... */ 
....................  
....................  
.................... void readLongRangeSensor() 
.................... { 
.................... } 
....................  
.................... void main() 
*
003C:  MOVF   03,W
003D:  ANDLW  1F
003E:  MOVWF  03
003F:  MOVLW  71
0040:  BSF    03.5
0041:  MOVWF  0F
0042:  CLRF   10
0043:  MOVF   0F,W
0044:  BCF    06.3
0045:  BCF    03.5
0046:  BSF    06.3
0047:  CLRF   20
0048:  CLRF   24
0049:  CLRF   23
004A:  MOVLW  13
004B:  MOVWF  22
004C:  MOVLW  88
004D:  MOVWF  21
004E:  MOVLW  FF
004F:  MOVWF  25
0050:  BSF    03.5
0051:  BSF    03.6
0052:  MOVF   09,W
0053:  ANDLW  C0
0054:  MOVWF  09
0055:  BCF    03.6
0056:  BCF    1F.4
0057:  BCF    1F.5
0058:  MOVLW  00
0059:  BSF    03.6
005A:  MOVWF  08
005B:  BCF    03.5
005C:  CLRF   07
005D:  CLRF   08
005E:  CLRF   09
005F:  BCF    03.7
.................... { 
....................    setup_oscillator(OSC_8MHZ,2); 
0060:  MOVLW  71
0061:  BSF    03.5
0062:  BCF    03.6
0063:  MOVWF  0F
0064:  MOVLW  02
0065:  MOVWF  10
0066:  MOVF   0F,W
....................    initStepper(); 
0067:  BCF    03.5
0068:  GOTO   00C
....................    while(TRUE) 
....................    { 
....................       stepperRotateSingleRight(1); 
0069:  MOVLW  01
006A:  MOVWF  26
006B:  GOTO   014
....................       delay_ms(500); 
006C:  MOVLW  02
006D:  MOVWF  26
006E:  MOVLW  FA
006F:  MOVWF  27
0070:  GOTO   026
0071:  DECFSZ 26,F
0072:  GOTO   06E
0073:  GOTO   069
....................        
....................    } 
.................... } 
0074:  GOTO   074

Configuration Fuses:
   Word  1: 0CF5   INTRC NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP DEBUG
   Word  2: 3FFF   BORV40 NOWRT

   Some fuses have been forced to be compatible with the ICD debugger.
